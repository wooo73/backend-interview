# Backend Interview

### Table Of Contents

---

-   [1. Backend](#backend)
-   [2. Javascript](#javascript)
-   [3. Typescript](#typescript)
-   [4. Database](#database)
-   [5. Framework](#framework)
-   [6. Infra](#infra)
-   [7. Data Structure](#data-structure)
-   [8. Network](#network)
-   [9. OS](#os)

### Backend

---

### Javascript

---

### Typescript

---

<details>
<summary>타입스크립트를 사용하는 주요 이점은 무엇인가요?</summary>
정적 타이핑을 지원하여 개발 단계에서 타입 오류를 미리 발견할 수 있어 런타임 에러를 줄이고, IDE에서 객체의 필드, 자료형등을 알려주므로 개발 생산성이 증가됩니다.</br>
제네릭, 인터페이스, 접근 제어자등을 통해 객체지향 프로그래밍을 쉽게 접할 수 있도록 도와줍니다.
</details>

<details>
<summary>정적 타입 시스템이란 무엇이며, 동적 타입 시스템과 어떻게 다른가요?</summary>
정적 타입 시스템은 타입이 명시되어 있으며, 코드가 실행되기 전 컴파일 시점에 타입을 체크합니다.</br>
동적 타입 시스템은 타입이 명시되지 않으며, 프로그램 실행 시점에 타입을 체크합니다.
</details>

<details>
<summary>타입 추론(Type Inference)이란 무엇인가요?</summary>
타입 추론은 개발자가 명시적으로 타입을 선언하지 않아도 초기 값이나 사용 방법을 분석하여 타입을 추론하는 기능입니다.
</details>

<details>
<summary>타입 어노테이션(Type Annotation)과 타입 어설션(Type Assertion)의 차이점은 무엇인가요?</summary>
타입 어노테이션은 변수, 함수 매개변수, 반환 값 등에 타입을 명시적으로 선언하는 방법입니다.</br>
타입 어설션은 개발자가 컴파일러에게 "나는 이 타입에 대해 더 잘 알고 있으니, 내가 지정한 타입으로 처리해줘"라고 말하는 방식입니다.(as 문법)</br>
타입 변환이 아닌, 컴파일러에게 타입 힌트를 제공하여 특정 타입으로 취급하도록 합니다. 런타임 오류가 발생할 수 있습니다.
</details>

<details>
<summary>인터페이스 확장(extends)과 구현(implements)의 차이점은 무엇인가요?</summary>
인터페이스 확장은 인터페이스가 다른 인터페이스의 모든 멤버를 상속받아 확장하는 것을 의미합니다.</br>
인터페이스 구현은 클래스가 인터페이스에 선언된 모든 속성과 메서드를 구현해야 합니다.</br>
클래스는 다른 클래스를 확장(extends)하면서 동시에 여러 인터페이스를 구현(implements)할 수 있습니다.
</details>

<details>
<summary>접근 제한자(Access Modifiers: public, private, protected)의 차이점은 무엇인가요?</summary>
public 접근 제한자는 클래스 멤버에 대한 접근을 제한하지 않습니다. 클래스 내부, 파생 클래스, 클래스 인스턴스 등 어디서든 접근할 수 있습니다.
private 접근 제한자는 클래스 멤버에 대한 접근을 해당 클래스 내부로만 제한합니다. 파생 클래스나 클래스 외부에서는 접근할 수 없습니다.
protected 접근 제한자는 클래스 멤버에 대한 접근을 해당 클래스와 파생 클래스 내부로 제한합니다. 클래스 외부에서는 접근할 수 없습니다.
</details>

<details>
<summary>추상 클래스(Abstract Class)와 인터페이스의 차이점은 무엇인가요?</summary>
추상 클래스는 abstract 키워드로 선언하며 구현된 메서드와 추상 메서드를 모두 포함할 수 있습니다.</br>
공통 기능을 구현하면서도 특정 기능은 파생 클래스에서 구현하도록 강제할 수 있어, 코드 재사용성을 높입니다.</br>
클래스는 extends 키워드를 사용해 하나의 추상 클래스만 상속받을 수 있으며, public, protected, private 접근 제한자를 모두 사용할 수 있습니다.</br>
인터페이스는 interface 키워드로 선언하며 메서드나 속성의 선언만 포함하고 구현 코드는 포함할 수 없습니다.</br>
클래스는 implements 키워드를 사용해 여러 인터페이스를 동시에 구현할 수 있어 다중 상속과 유사한 효과를 얻을 수 있습니다.</br>
인터페이스는 접근 제한자를 사용할 수 없으며 모든 멤버는 기본적으로 public입니다.
</details>

### Database

---

<details>
<summary>DDL, DML, DCL, TCL의 차이점과 각각의 주요 명령어는 무엇인가요?</summary>
DDL은 데이터 정의어로 테이블과 컬럼을 정의하는 명령어입니다. 데이터베이스의 골격을 결정하며, CREATE, ALTER, DROP, TRUNCATE 등과 같은 명령어가 있습니다.</br>
DML은 데이터 조작어로 데이터베이스 내부 데이터를 관리하기 위한 명령어입니다. 데이터 조회, 추가, 변경, 삭제 등의 작업을 수행하며, SELECT, INSERT, UPDATE, DELETE 등이 포함됩니다.</br>
DCL은 데이터 제어 언어로 데이터베이스에 대한 접근 권한을 제어하기 위해 사용됩니다. GRANT, REVOKE 등의 명령어가 있습니다.</br>
TCL은 트랜잭션 제어 언어로 트랜잭션을 제어할 때 사용합니다. COMMIT, ROLLBACK, SAVEPOINT 등의 명령어가 있습니다.</br>
</details>

<details>
<summary>SELECT 문의 기본 구조와 실행 순서에 대해 설명해주세요.</summary>
일반적으로 SELECT 쿼리문은 FROM, WHERE, GROUP BY, HAVING, SELECT, ORDER BY 순으로 총 6단계를 거치며 처리됩니다.
</details>

<details>
<summary>서브쿼리(Subquery)란 무엇이며, 어떤 종류가 있나요?</summary>
SQL 쿼리 내부에 포함된 또 다른 SELECT 쿼리를 의미합니다.</br>
사용되는 위치, 반환 값, 사용 용도에 따라 스칼라, 인라인 뷰, 중첩 서브쿼리로 나뉘게 됩니다.
</details>

<details>
<summary>서브쿼리(Subquery)의 종류와 특징에 대해서 설명해주세요.</summary>
서브쿼리의 종류로는 스칼라 서브쿼리, 인라인 뷰, 중첩 서브쿼리가 있습니다.</br>
스칼라 서브쿼리는 단일 행의 단일 컬럼을 반환하는 서브쿼리로, SELECT 절에서 주로 사용되며 하나의 값처럼 취급됩니다.</br>
인라인 뷰 서브쿼리는 FROM 절에서 사용되며, 여러 행과 여러 열을 반환하는 테이블 형태의 결과를 생성하여 메인쿼리에서 가상의 테이블처럼 사용됩니다.</br>
중첩 서브쿼리는 WHERE 절에 위치하며, 메인쿼리 테이블의 특정 값과 비교한 값을 반환하는 용도로 사용됩니다.
</details>

<details>
<summary>JOIN 연산의 성능을 최적화하는 방법은 무엇인가요?</summary>
EXPLAIN을 통해 조인 쿼리의 실행 계획을 분석후 조치합니다.</br>
작은 테이블을 먼저 조인하고, 필요한 데이터만 선택하여 조인합니다.</br>
조인 전 WHERE 절을 사용하여 미리 필터링 하여 조인할 데이터 양을 줄이도록 합니다.</br>
조인 조건에 인덱스를 활용하여 데이터 검색 시간을 단축하도록 합니다.
</details>

<details>
<summary>정규화란 무엇이며, 왜 필요한가요?</summary>
정규화는 데이터베이스 설계 시 중복 데이터를 최소화하고 데이터 무결성을 보장하기 위해 테이블을 체계적으로 분해하는 과정입니다.</br>
정규화는 1 ~ 6 정규화까지 여러 과정이 존재하지만, 보통 1~3 정규화까지의 과정을 거치게 된다고 알고있습니다.

**추가**

-   제1 정규화는 테이블의 모든 컬럼이 원자값(더 이상 분해할 수 없는 단일 값)을 가지도록 테이블을 분해합니다.
-   제2 정규화는 제1 정규화를 진행한 테이블에, 부분 함수적 종속성을 제거하여 모든 비주요 속성이 주요 키에 완전 함수적 종속이 되도록 테이블을 분해합니다.
-   제3 정규화는 제2 정규화를 진행한 테이블에, 이행적 함수적 종속성을 제거하여 비주요 속성 간의 종속성을 제거합니다.
-   BCNF(Boyce-Codd 정규형): 모든 결정자가 후보키가 되도록 테이블을 분해합니다.

</details>

<details>
<summary>반정규화(Denormalization)란 무엇이며, 언제 사용하나요?</summary>
반정규화는 정규화된 데이터베이스의 성능을 향상시키기 위해 의도적으로 정규화 원칙을 위배하여 데이터 중복을 허용하는 기법입니다.</br>
읽기 작업이 많고 데이터 일관성보다 조회 성능이 중요한 시스템에서 사용됩니다.

**추가**

-   테이블 병합: 정규화로 분리된 테이블을 다시 하나로 합쳐 조인 연산을 줄입니다.
-   컬럼 복제: 자주 조회되는 컬럼을 다른 테이블에 복제하여 조인 없이 데이터에 접근할 수 있게 합니다.
-   파생 컬럼 추가: 계산된 값을 미리 저장하여 실시간 계산 비용을 줄입니다.
-   요약 테이블 생성: 집계 데이터를 별도 테이블에 저장하여 분석 쿼리 성능을 향상시킵니다.

</details>

### Framework

---

### Infra

---

### Data Structure

---

### Network

---

### OS
